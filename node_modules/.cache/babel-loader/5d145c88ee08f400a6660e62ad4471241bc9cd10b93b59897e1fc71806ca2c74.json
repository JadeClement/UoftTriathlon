{"ast":null,"code":"// Installs a global fetch wrapper that automatically handles auth errors\n// - Attaches Authorization header if getToken() returns a token\n// - If response is 401/403 or contains a token-expired style error, it calls onUnauthorized()\n\nexport function installFetchInterceptor(getToken, onUnauthorized) {\n  if (typeof window === 'undefined' || typeof window.fetch !== 'function') return () => {};\n\n  // Prevent double installation\n  if (window.__authFetchInstalled) {\n    return window.__removeAuthFetch || (() => {});\n  }\n  const originalFetch = window.fetch.bind(window);\n  async function authAwareFetch(input, init = {}) {\n    try {\n      const url = typeof input === 'string' ? input : input.url;\n\n      // Don't intercept login/auth endpoints to avoid redirect loops\n      if (url && (url.includes('/auth/login') || url.includes('/auth/register') || url.includes('/auth/forgot-password'))) {\n        return originalFetch(input, init);\n      }\n      const token = typeof getToken === 'function' ? getToken() : null;\n      const headers = new Headers(init && init.headers ? init.headers : {});\n      if (token && !headers.has('Authorization')) {\n        headers.set('Authorization', `Bearer ${token}`);\n      }\n      const response = await originalFetch(input, {\n        ...init,\n        headers\n      });\n\n      // Fast path: OK responses\n      if (response.status < 400) return response;\n\n      // Try to detect token problems\n      let body;\n      try {\n        // Clone first so consumers can still read it later\n        const clone = response.clone();\n        body = await clone.json();\n      } catch (_) {\n        // ignore JSON parse errors\n      }\n      const isAuthError = response.status === 401 || response.status === 403;\n      const message = body && (body.error || body.message) || '';\n      const mentionsExpired = /token.*expired|jwt.*expired|expired token/i.test(message);\n      if (isAuthError || mentionsExpired) {\n        if (typeof onUnauthorized === 'function') {\n          onUnauthorized({\n            status: response.status,\n            message\n          });\n        }\n      }\n      return response;\n    } catch (err) {\n      // Network errors fall through untouched\n      throw err;\n    }\n  }\n  window.fetch = authAwareFetch;\n  window.__authFetchInstalled = true;\n  window.__removeAuthFetch = () => {\n    if (window.__authFetchInstalled) {\n      window.fetch = originalFetch;\n      window.__authFetchInstalled = false;\n      delete window.__removeAuthFetch;\n    }\n  };\n  return window.__removeAuthFetch;\n}","map":{"version":3,"names":["installFetchInterceptor","getToken","onUnauthorized","window","fetch","__authFetchInstalled","__removeAuthFetch","originalFetch","bind","authAwareFetch","input","init","url","includes","token","headers","Headers","has","set","response","status","body","clone","json","_","isAuthError","message","error","mentionsExpired","test","err"],"sources":["/Users/jadeclement/Documents/Developer/uofttri/src/utils/installFetchInterceptor.js"],"sourcesContent":["// Installs a global fetch wrapper that automatically handles auth errors\n// - Attaches Authorization header if getToken() returns a token\n// - If response is 401/403 or contains a token-expired style error, it calls onUnauthorized()\n\nexport function installFetchInterceptor(getToken, onUnauthorized) {\n  if (typeof window === 'undefined' || typeof window.fetch !== 'function') return () => {};\n\n  // Prevent double installation\n  if (window.__authFetchInstalled) {\n    return window.__removeAuthFetch || (() => {});\n  }\n\n  const originalFetch = window.fetch.bind(window);\n\n  async function authAwareFetch(input, init = {}) {\n    try {\n      const url = typeof input === 'string' ? input : input.url;\n      \n      // Don't intercept login/auth endpoints to avoid redirect loops\n      if (url && (url.includes('/auth/login') || url.includes('/auth/register') || url.includes('/auth/forgot-password'))) {\n        return originalFetch(input, init);\n      }\n      \n      const token = typeof getToken === 'function' ? getToken() : null;\n\n      const headers = new Headers(init && init.headers ? init.headers : {});\n      if (token && !headers.has('Authorization')) {\n        headers.set('Authorization', `Bearer ${token}`);\n      }\n\n      const response = await originalFetch(input, { ...init, headers });\n\n      // Fast path: OK responses\n      if (response.status < 400) return response;\n\n      // Try to detect token problems\n      let body;\n      try {\n        // Clone first so consumers can still read it later\n        const clone = response.clone();\n        body = await clone.json();\n      } catch (_) {\n        // ignore JSON parse errors\n      }\n\n      const isAuthError = response.status === 401 || response.status === 403;\n      const message = (body && (body.error || body.message)) || '';\n      const mentionsExpired = /token.*expired|jwt.*expired|expired token/i.test(message);\n\n      if (isAuthError || mentionsExpired) {\n        if (typeof onUnauthorized === 'function') {\n          onUnauthorized({ status: response.status, message });\n        }\n      }\n\n      return response;\n    } catch (err) {\n      // Network errors fall through untouched\n      throw err;\n    }\n  }\n\n  window.fetch = authAwareFetch;\n  window.__authFetchInstalled = true;\n  window.__removeAuthFetch = () => {\n    if (window.__authFetchInstalled) {\n      window.fetch = originalFetch;\n      window.__authFetchInstalled = false;\n      delete window.__removeAuthFetch;\n    }\n  };\n\n  return window.__removeAuthFetch;\n}\n\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}